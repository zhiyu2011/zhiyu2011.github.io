<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[闫旭亮]的个人博客">
<meta name="author" content="kveln">
<title>Git命令大全 | 闫旭亮</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="Git命令大全 | 闫旭亮 » Feed"
  href="https://2011369.xyz//atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://2011369.xyz//styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="Git命令大全" />
  <meta property="og:url" content="https://2011369.xyz/mnVQCPF5u/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="闫旭亮" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://2011369.xyz/">闫旭亮</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://zhiyu2011.github.io/about" target="_blank">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1769763236927"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://2011369.xyz/">闫旭亮</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://zhiyu2011.github.io/about" target="_blank">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1769763236927"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://2011369.xyz//media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://2011369.xyz/duuPOqJ8r/" class="tag">学习</a>
                
                <a href="https://2011369.xyz/z_W2VbSYg/" class="tag">Gridea</a>
                
              </span>
              <h1>Git命令大全</h1>
              <span class="meta">
                Posted on
                2022-11-24，32 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <p>以下内容是我在学习和研究Git时，对Git操作的特性、重点和注意事项的提取、精练和总结，可以做为Git操作的字典，方便大家查阅；如果你从未接触过Git，希望看一个入门级别的教程，请移步到《Git基础教程》</p>
<p>备注：本文会不断更新完善；</p>
<p>目录</p>
<ol>
<li>语法格式描述</li>
<li>存放git环境变量的几个位置</li>
<li>配置<br>
3.1. 用户信息<br>
3.2. 查看配置信息<br>
3.3. 文本编辑器<br>
3.4. 差异分析工具</li>
<li>获取帮助</li>
<li>Git常用命令<br>
5.1. 获得项目的Git仓库<br>
5.1.1. 在工作目录中初始化新仓库<br>
5.1.2. 从现有仓库克隆<br>
5.2. 添加跟踪文件、暂存<br>
5.3. 检查当前文件状态<br>
5.4. 忽略某些文件<br>
5.5. 查看已暂存和未暂存的更新<br>
5.6. 提交更新<br>
5.7. 移除文件<br>
5.8. 移动文件<br>
5.9. 查看提交历史<br>
5.10. 撤消操作<br>
5.10.1. 修改最后一次提交<br>
5.10.2. 取消已经暂存的文件<br>
5.10.3. 取消对文件的修改<br>
5.11. 远程仓库<br>
5.11.1. 查看当前的远程库<br>
5.11.2. 添加远程仓库<br>
5.11.3. 从远程仓库抓取数据<br>
5.11.4. 推送数据到远程仓库<br>
5.11.5. 删除远程分支<br>
5.11.6. 查看远程仓库信息<br>
5.11.7. 远程仓库的重命名<br>
5.11.8. 远程仓库的删除<br>
5.12. 标签<br>
5.12.1. 列出已有的标签<br>
5.12.2. 新建标签<br>
5.12.3. 签署标签<br>
5.12.4. 验证标签<br>
5.12.5. 后期加注标签<br>
5.12.6. 分享标签<br>
5.13. 新建分支<br>
5.14. 切换分支<br>
5.15. 新建并切换分支<br>
5.16. 合并分支<br>
5.17. 删除分支<br>
5.18. 强制删除分支<br>
5.19. 查看当前分支列表<br>
5.20. 查看各个分支最后一次提交对象的信息<br>
5.21. 查看已经合并到当前所在分支的分支<br>
5.22. 查看未合并到当前所在分支的分支<br>
5.23. 跟踪远程分支<br>
5.24. 删除远程分支<br>
5.25. 分支的变基（衍合）</li>
<li>分支、HEAD、ref的区别</li>
<li>远程分支、远程跟踪分支、跟踪分支的区别</li>
<li>命令详解<br>
8.1. 克隆clone<br>
8.2. 远程remote<br>
8.2.1. 显示远程仓库信息<br>
8.2.2. 添加远程仓库<br>
8.2.3. 设置远程跟踪分支<br>
8.3. 获取fetch<br>
8.4. 拉取pull<br>
8.5. 分支branch<br>
8.5.1. 显示或删除分支<br>
8.5.2. 创建分支<br>
8.5.3. 为分支设置上游分支（远程跟踪分支）<br>
8.6. 提交commit<br>
8.7. 推送push</li>
<li>技术及Git问题解决方案</li>
<li>相关文章<br>
内容</li>
<li>语法格式描述<br>
本文采用BNF语法格式描述规范描述命令行的语法，BNF语法格式的元字符及其含义如下：<br>
[ ]：可选内容；<br>
&lt; &gt;：必须给出内容；<br>
{ }：可重复0至无数次的内容；<br>
a|b|c：多选一；<br>
…：可以有多个；</li>
</ol>
<p>备注：关于BNF的详细内容可参考《语法格式描述规范BNF、EBNF、ABNF》</p>
<ol start="2">
<li>存放git环境变量的几个位置<br>
git支持多级配置，如：系统级、用户级、项目级、工作区级；它们的优先级如下：工作区级配置 &gt; 项目级配置 &gt; 用户级配置 &gt; 系统级配置；每级配置记录在对应的配置文件中，通过 git config 命令设置的配置项 也都会写在对应的配置文件中，配置文件的具体信息如下：</li>
</ol>
<p>/etc/gitconfig ：系统级配置文件；对系统中所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。<br>
~/.gitconfig ：用户级配置文件；用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。<br>
当前项目的 git仓库目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。若使用 git config 时用 --local 选项 或 省略，读写的就是这个文件。<br>
工作区级配置文件 ：这里的配置仅仅针对当前工作区有效。若使用 git config 时用 --worktree 选项，读写的就是这个文件。<br>
3. 配置<br>
3.1. 用户信息<br>
git config --global user.name &quot;John Doe&quot;<br>
git config --global user.email johndoe@example.com<br>
如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<p>3.2. 查看配置信息<br>
git config --list<br>
有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<p>git config user.name Scott Chacon<br>
3.3. 文本编辑器<br>
Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p>
<p>git config --global core.editor emacs<br>
3.4. 差异分析工具<br>
在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<p>git config --global merge.tool vimdiff<br>
Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具；</p>
<ol start="4">
<li>获取帮助<br>
想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：</li>
</ol>
<p>git help [命令]<br>
git [命令] --help<br>
man git<br>
比如，要学习 config 命令可以怎么用，运行：</p>
<p>git help config<br>
5. Git常用命令<br>
5.1. 获得项目的Git仓库<br>
有2种获得 Git 项目仓库的方法：</p>
<p>通过Git的init命令初始化一个新仓库；<br>
通过Git的clone命令从已有的 Git 仓库(可以是本地的，也可以是远程的)克隆出一个新的镜像仓库来。<br>
5.1.1. 在工作目录中初始化新仓库<br>
要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<p>git init<br>
5.1.2. 从现有仓库克隆<br>
命令格式:</p>
<p>$ git clone [url]<br>
比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<p>git clone git://github.com/schacon/grit.git<br>
如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<p>git clone git://github.com/schacon/grit.git mygrit<br>
如果希望克隆时直检出指定的分支，可以指定 -b &lt;分支名&gt; 选项，如下：</p>
<p>git clone  -b Tool  https://gitee.com/guobinyong/Opus.git 工具<br>
通常clone命令会把整个仓库的(包含所有分支的)版本数据给克隆下来，如果只想获取某个分支的版本数据，只需要加上 --single-branch选项，如下：</p>
<p>git clone  --single-branch  -b Tool  https://gitee.com/guobinyong/Opus.git 工具<br>
如果你想在克隆仓库时给仓库设置一些不同于全局的git配置，可以通过 --config 选项，其简写选项是 -c，比如，你想给克隆的仓库设置 用户名 和 邮箱：</p>
<p>git clone  --config user.name=郭斌勇 -c user.email=guobinyong@qq.com  https://gitee.com/guobinyong/Opus.git 工具<br>
5.2. 添加跟踪文件、暂存<br>
git add  文件名<br>
这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等；<br>
其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。</p>
<p>5.3. 检查当前文件状态<br>
git status<br>
5.4. 忽略某些文件<br>
在工作区根目录下创建一个名为 .gitignore 的文件，列出要忽略的文件模式；</p>
<p>文件 .gitignore 的格式规范如下：</p>
<p>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br>
在一行的末尾添加注释，会使该行被Git忽略，所以注释只能独占一行，不能添加在行的末尾；<br>
可以使用标准的 glob 模式匹配。<br>
匹配模式最后跟反斜杠（/）说明要忽略的是目录。<br>
要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。<br>
所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>
<p>.gitignore 文件的例子：</p>
<h1 id="此为注释-将被-git-忽略">此为注释 – 将被 Git 忽略</h1>
<h1 id="忽略所有-a-结尾的文件">忽略所有 .a 结尾的文件</h1>
<p>*.a</p>
<h1 id="但-liba-除外">但 lib.a 除外</h1>
<p>!lib.a</p>
<h1 id="仅仅忽略项目根目录下的-todo-文件不包括-subdirtodo">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</h1>
<p>/TODO</p>
<h1 id="忽略-build-目录下的所有文件">忽略 build/ 目录下的所有文件</h1>
<p>build/</p>
<h1 id="会忽略-docnotestxt-但不包括-docserverarchtxt">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</h1>
<p>doc/*.txt<br>
5.5. 查看已暂存和未暂存的更新<br>
git diff<br>
此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>
若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）。</p>
<p>5.6. 提交更新<br>
git commit<br>
这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以使用 git config --global core.editor 命令设定你喜欢的编辑软件。）</p>
<p>另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新：</p>
<p>git commit -m “说明文字&quot;<br>
Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上-a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p>
<p>git commit -a -m ‘文字说明'<br>
5.7. 移除文件<br>
要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了，如：</p>
<p>git rm 文件<br>
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 --cached 选项即可：</p>
<p>git rm --cached 文件<br>
后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p>
<p>git rm log/*.log<br>
注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有log/ 目录下扩展名为 .log 的文件。类似的比如：</p>
<p>git rm *~<br>
会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p>
<p>5.8. 移动文件<br>
git mv 文件_from  文件_to<br>
其实，运行 git mv 就相当于运行了下面三条命令：</p>
<p>mv  文件_from  文件_to<br>
git rm  文件_from<br>
git add  文件_to<br>
5.9. 查看提交历史<br>
git log<br>
选项说明：</p>
<p>-p 按补丁格式显示每个更新之间的差异。<br>
--stat 显示每次更新的文件修改统计信息。<br>
--shortstat 只显示 --stat 中最后的行数修改添加移除统计。<br>
--name-only 仅在提交信息后显示已修改的文件清单。<br>
--name-status 显示新增、修改、删除的文件清单。<br>
--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。<br>
--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。<br>
--graph 显示 ASCII 图形表示的分支合并历史。<br>
--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。<br>
-(n)    仅显示最近的 n 条提交<br>
--since, --after 仅显示指定时间之后的提交。<br>
--until, --before 仅显示指定时间之前的提交。<br>
--author 仅显示指定作者相关的提交。<br>
--committer 仅显示指定提交者相关的提交。<br>
5.10. 撤消操作<br>
5.10.1. 修改最后一次提交<br>
git commit --amend<br>
此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。<br>
如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：</p>
<p>git commit -m 'initial commit'<br>
git add forgotten_file<br>
git commit --amend<br>
上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p>5.10.2. 取消已经暂存的文件<br>
git reset HEAD <file>…<br>
5.10.3. 取消对文件的修改<br>
git checkout -- <file>…<br>
5.11. 远程仓库<br>
5.11.1. 查看当前的远程库<br>
git remote<br>
查看当前配置的远程仓库。它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库；</p>
<p>-v ：（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址；<br>
5.11.2. 添加远程仓库<br>
git remote add [仓库名] [url]<br>
添加一个新的远程仓库，指定名字为 仓库名，以便将来引用；</p>
<p>5.11.3. 从远程仓库抓取数据<br>
git fetch [远程仓库名]<br>
此命令会到名为 远程仓库名 的远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p>
<p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。<br>
如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<p>5.11.4. 推送数据到远程仓库<br>
git push [远程仓库S] [本地分支L]:[远程分支R]<br>
表示：把 本地分支L 推送到 远程仓库S 的 远程分支R 中，如果 远程仓库S 中不存在 远程分支R，则会在 远程仓库S 中 创建 远程分支R 并把 本地分支L 推送到 远程分支R 中；如果本地分支L和远程分支R名字相同，则可以简写为：</p>
<p>git push [远程仓库S] [本地分支L]<br>
只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p>
<p>5.11.5. 删除远程分支<br>
git push [远程仓库S] :[远程分支R]<br>
这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 git push [远程仓库S] [本地分支L]:[远程分支R]，省略 本地分支L 表示：在这里提取空白然后把它变成 远程分支R。</p>
<p>5.11.6. 查看远程仓库信息<br>
git remote show [远程仓库名]<br>
查看名为 远程仓库名 的远程仓库的详细信息</p>
<p>5.11.7. 远程仓库的重命名<br>
git remote rename  [远程仓库旧名]   [远程仓库新名]<br>
修改某个远程仓库在本地的名称（新版 Git 中支持）；<br>
注意，对远程仓库的重命名，也会使对应的分支名称发生变化;</p>
<p>5.11.8. 远程仓库的删除<br>
git remote rm  [远程仓库名]<br>
5.12. 标签<br>
5.12.1. 列出已有的标签<br>
git tag<br>
5.12.2. 新建标签<br>
Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特 定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标 签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<p>含附注的标签：<br>
创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p>
<p>git tag -a v1.4 -m 'my version 1.4’<br>
而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p>
<p>git show v1.4<br>
轻量级标签：<br>
轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：</p>
<p>git tag v1.4-lw<br>
5.12.3. 签署标签<br>
如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可：</p>
<p>git tag -s v1.5 -m 'my signed 1.5 tag’<br>
5.12.4. 验证标签<br>
可以使用 git tag -v [标签名] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：</p>
<p>5.12.5. 后期加注标签<br>
我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：</p>
<p>git tag -a v1.2 9fceb02<br>
5.12.6. 分享标签<br>
默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可;<br>
如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项;</p>
<p>5.13. 新建分支<br>
git branch  [分支名]<br>
注意：此命令仅仅是建立了一个新的分支，但不会自动切换到这个分支中去；</p>
<p>5.14. 切换分支<br>
switch 和 checkout 都可以切换分支</p>
<p>git switch 分支名 ：推荐，版本 2.23 才有 switch 命令；<br>
git checkout 分支名<br>
5.15. 新建并切换分支<br>
switch 和 checkout 都可以新建并切换分支</p>
<p>git switch 分支名 | git switch -c [分支名] ：推荐，版本 2.23 才有 switch 命令；<br>
git checkout -b [分支名]<br>
相当于以下2条命令：</p>
<p>git branch [分支名]<br>
git checkout [分支名]<br>
5.16. 合并分支<br>
设当前分支为A</p>
<p>git merge [分支B]<br>
此命令表示，把分支B合并到分支A</p>
<p>5.17. 删除分支<br>
git branch -d [分支名]<br>
5.18. 强制删除分支<br>
git branch -D [分支名]<br>
5.19. 查看当前分支列表<br>
git branch<br>
返回结果如下：</p>
<p>iss53</p>
<ul>
<li>master<br>
testing<br>
带有 * 的分支表示是当前所在的分支；</li>
</ul>
<p>5.20. 查看各个分支最后一次提交对象的信息<br>
git branch -v<br>
5.21. 查看已经合并到当前所在分支的分支<br>
git branch --merged<br>
5.22. 查看未合并到当前所在分支的分支<br>
git branch --no-merged<br>
5.23. 跟踪远程分支<br>
git checkout -b [分支名] [远程仓库名]/[分支名]<br>
在1.6.2 以上版本的 Git，可以用 --track 选项简化：</p>
<p>git checkout --track [远程仓库名]/[分支名]<br>
5.24. 删除远程分支<br>
git push [远程仓库S] :[远程分支R]<br>
这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 git push [远程仓库S] [本地分支L]:[远程分支R]，省略 本地分支L 表示：在这里提取空白然后把它变成 远程分支R。</p>
<p>5.25. 分支的变基（衍合）<br>
git rebase [--onto 基分支] [参考分支 [变基分支]]<br>
表示：将包含在 变基分支 但不包含在 参考分支 的提交 追加到 基分支 后面；注意：这个操作更改的是 变基分支，并不更改 基分支，只是以 基分支 为 基；</p>
<p>如果没指定 基分支，则 基分支 默认为 参考分支<br>
如果指定了 变基分支 ，则 git 在执行其它操作之前，会先切换到 变基分支，然后再进行接下来的变基操作；如果没有指定 变基分支，则 变基分支 默认为 当前分支，并且在当前分支进行变基操作；<br>
如果没有指定 参考分支，则 参考分支 默认为 变基分支 配置的 上游分支<br>
6. 分支、HEAD、ref的区别<br>
ref 就是引用、指针的意思；<br>
Git 中的分支，其实本质上仅仅是个指向 提交（commit） 对象的可变指针；创建分支的过程就是创建分支指针；<br>
HEAD 是一个总是指向当前本地分支指针的指针，它表示当前分支；<br>
7. 远程分支、远程跟踪分支、跟踪分支的区别<br>
远程分支：在远程仓库中的分支，就是像本地分支一样的普通分支，只不过是在远程仓库里；<br>
远程跟踪分支：本地仓库中用来代表远程分支的本地分支，它是只读的，只是表示远程分支的状态，本地不可修改；<br>
跟踪分支：已跟踪了远程跟踪分支的本地分支，可以通过pull和push命令快捷地获取合并数据和推送数据；<br>
远程跟踪分支 是 跟踪分支 与 远程分支 之间的跟踪桥梁；</p>
<ol start="8">
<li>命令详解<br>
8.1. 克隆clone<br>
语法：</li>
</ol>
<p>git clone [-b &lt;远程分支&gt;] [--single-branch] &lt;远程仓库&gt; [本地目录]<br>
说明：<br>
从 远程仓库 克隆指定的 远程分支 到 本地目录 下；<br>
如果 本地目录 不存在，则会创建相应的本地目录；</p>
<p>选项：<br>
-b &lt;远程分支&gt; ：创建指定 远程分支 的跟踪分支；如果不指定该选项，则会自动创建 master 跟踪分支；<br>
--single-branch : 仅获取指定的单个分支的数据，并且仅创建指定分支的远程跟踪分支和跟踪分支；如果不指定该选项，则会获取远程仓库的所有分支的数据，并为远程仓库中的所有分支创建相应的远程跟踪分支；</p>
<p>8.2. 远程remote<br>
remote 命令用于设置被当前本地仓库跟踪的远程仓库；</p>
<p>8.2.1. 显示远程仓库信息<br>
语法：</p>
<p>git remote [-v | --verbose]<br>
说明：<br>
显示所有的远程仓库；</p>
<p>选项：<br>
-v, --verbose ：提供更多的信息；</p>
<p>8.2.2. 添加远程仓库<br>
语法：</p>
<p>git remote add {-t &lt;远程分支&gt;]} &lt;远程仓库名&gt; <url><br>
说明：<br>
添加新的远程仓库并命名为 远程仓库名 ，设置其仓库地址为 <url>；<br>
远程仓库被添加之后，就可以用命令 git fetch &lt;远程仓库名&gt; 更新 远程跟踪分支；</p>
<p>选项：<br>
-t &lt;远程分支&gt; ：创建指定的 远程分支 的远程跟踪分支；可以指定多个 -t &lt;远程分支&gt; 创建多个远程跟踪分支；</p>
<p>8.2.3. 设置远程跟踪分支<br>
语法：</p>
<p>git remote set-branches [--add] &lt;远程仓库&gt; &lt;远程分支&gt;...<br>
说明：<br>
重新为 远程仓库 的远程分支 设置 远程跟踪分支；</p>
<p>选项：<br>
--add ：为 远程仓库 的远程分支 添加 远程跟踪分支；</p>
<p>8.3. 获取fetch<br>
语法：</p>
<p>git fetch [选项] [&lt;远程仓库&gt; [[远程分支][:&lt;本地分支&gt;]]<br>
说明：<br>
从 远程仓库 获取 指定的 远程分支 的更新到相应的远程跟踪分支，并把数据同步到 本地分支；<br>
如果 本地分支 不存在，则会创建该本地分支；</p>
<p>如果省略了 本地分支 (如下)则只是取回指定 远程仓库 的指定 远程分支 的更新到到相应的远程跟踪分支；</p>
<p>git fetch [选项] &lt;远程仓库&gt; [远程分支]<br>
如果省略 远程分支 和 本地分支 (如下)则会取回指定 远程仓库 的已被跟踪的所有远程分支的更新到相应的远程跟踪分支；</p>
<p>git fetch [选项] &lt;远程仓库&gt;<br>
如果仅省略 远程分支 (如下)则会取回指定 远程仓库 的远 master 远程分支的更新到到相应的远程跟踪分支，并把数据同步到指定的 本地分支；</p>
<p>git fetch [选项] &lt;远程仓库&gt; :&lt;本地分支&gt;<br>
相当于：</p>
<p>git fetch [选项] &lt;远程仓库&gt; master:&lt;本地分支&gt;<br>
如果省略 远程仓库 、 远程分支 和 本地分支 (如下)则会取回跟踪的所有仓库的已被跟踪的所有分支的更新到相应的远程跟踪分支；</p>
<p>git fetch [选项]<br>
8.4. 拉取pull<br>
语法：</p>
<p>git pull [选项] [&lt;远程仓库&gt; [[远程分支][:&lt;本地分支&gt;]]<br>
说明：<br>
从 远程仓库 获取指定的 远程分支 的更新到相应的远程跟踪分支，并合并到 本地分支；<br>
如果 本地分支 不存在，则会创建该本地分支；</p>
<p>选项：<br>
-f | --force : 强制拉取并合并到 本地分支，如果 远程分支与 本地分支 不一致，则会用 远程分支 覆盖 本地分支；<br>
-t | --tags : 从远程拉取所有的标签 tag ；<br>
-r | --rebase : 以变基 rebase 的方式进行合并；将本地分支中新的提交拼接到上游分支的后面；</p>
<p>8.5. 分支branch<br>
8.5.1. 显示或删除分支<br>
语法：</p>
<p>git branch [选项]<br>
说明：<br>
显示或者删除（如果指定了删除选项）当前仓库的相关分支；</p>
<p>选项：<br>
-d, --delete ：删除指定的分支；<br>
-D ：强制删除指定的分支；<br>
-a, --all：显示远程跟踪分支和本地分支；<br>
-r, --remotes ：显示或者删除远程跟踪分支；<br>
-r, --remotes ：显示或者删除远程跟踪分支；<br>
-v, -vv, --verbose：提供更多的信息；注意：-v 和 -vv 提供的信息不一样；</p>
<p>8.5.2. 创建分支<br>
语法：</p>
<p>git branch [--set-upstream | --track] &lt;分支名&gt; [&lt;起始指针&gt;]<br>
说明：<br>
创建新分支并设置其名这 分支名 ，且设置该分支的起始指针为 起始指针；</p>
<p>选项：<br>
--set-upstream | --track ：跟踪 起始指针 所指向的分支；</p>
<p>8.5.3. 为分支设置上游分支（远程跟踪分支）<br>
语法：</p>
<p>git branch (--set-upstream-to=&lt;上游分支&gt; | -u &lt;上游分支&gt;) [&lt;分支&gt;]<br>
说明：<br>
为指定的 分支 设置 上游分支 （即远程跟踪分支）； 如果没有指定 分支 则默认使用当前所在分支；</p>
<p>8.6. 提交commit<br>
语法：</p>
<p>git commit [--amend] [-m &lt;提交说明&gt;]<br>
说明：<br>
提交暂存的更新；</p>
<p>选项：<br>
-m &lt;提交说明&gt; ：指定提交说明；如果不指定该选项，则会启动文本编辑器以便输入本次提交的说明；<br>
--amend ：修改最后一次的提交；即不会生成新的提交对象；</p>
<p>8.7. 推送push<br>
语法：</p>
<p>git push [-u | --set-upstream] [--tags] [-f | --force] [--force-with-lease] [远程仓库S] [本地分支L][:&lt;远程分支R&gt;]<br>
说明：</p>
<p>表示：把 本地分支L 推送到 远程仓库S 的 远程分支R 中，如果 远程仓库S 中不存在 远程分支R，则会在 远程仓库S 中 创建 远程分支R 并把 本地分支L 推送到 远程分支R 中；<br>
如果省略了 远程分支R ，即：git push [远程仓库S] [本地分支L]，则会把本地分支L 推送到 远程仓库S 中与 本地分支L 同名的远程分支中；<br>
如果省略了 本地分支L ，即：git push [远程仓库S] :[远程分支R]，则会删除 远程仓库S 中的 远程分支R；<br>
注意：<br>
只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p>
<p>选项：<br>
-u | --set-upstream : 为推送的每一个分支设置设置上游分支（远程跟踪分支）；<br>
--tags : 推送所有本地新增的标签到远程仓库；默认情况下，push 并不会把标签推送到远程仓库中，只有通过显式命令才能推送标签到远程仓库；<br>
-f | --force : 强制推送，如果 远程分支 与 本地分支 不一致，则会用 本地分支 覆盖 远程分支；<br>
--force-with-lease : 比 -f | --force 更安全一些强制推送，如果 远端仓库 的 目标分支 有其他人推送了新的提交，且这些提交还没有被 fetch 到 本地仓库，那么推送将会被拒绝；</p>
<ol start="9">
<li>
<p>技术及Git问题解决方案<br>
关于Git的技巧和一些问题的解决方案请看 Git技巧和问题解决方案</p>
</li>
<li>
<p>相关文章<br>
Git并行工作流程规范<br>
Git基础教程<br>
Git命令大全<br>
Git技巧和问题解决方案<br>
Git中合并多个提交的各种方法<br>
Git并行工作流程规范设计记录<br>
弃用SVN选择Git的理由<br>
Git和Subversion的命令的对比<br>
分布式和集中式版本控制系统的区别<br>
Git的存储机制</p>
</li>
</ol>
<p>作者：科研者<br>
链接：https://www.jianshu.com/p/15a4dee9c5df<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#%E6%AD%A4%E4%B8%BA%E6%B3%A8%E9%87%8A-%E5%B0%86%E8%A2%AB-git-%E5%BF%BD%E7%95%A5">此为注释 – 将被 Git 忽略</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E6%89%80%E6%9C%89-a-%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6">忽略所有 .a 结尾的文件</a></li>
<li><a href="#%E4%BD%86-liba-%E9%99%A4%E5%A4%96">但 lib.a 除外</a></li>
<li><a href="#%E4%BB%85%E4%BB%85%E5%BF%BD%E7%95%A5%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84-todo-%E6%96%87%E4%BB%B6%E4%B8%8D%E5%8C%85%E6%8B%AC-subdirtodo">仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5-build-%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6">忽略 build/ 目录下的所有文件</a></li>
<li><a href="#%E4%BC%9A%E5%BF%BD%E7%95%A5-docnotestxt-%E4%BD%86%E4%B8%8D%E5%8C%85%E6%8B%AC-docserverarchtxt">会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</a></li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://2011369.xyz/RPBxR9x6n/">
              <span class="post-title">
                Hexo常用的命令：&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            
            <span id="/post//" class="leancloud_visitors"
              data-flag-title="Git命令大全">
              <em class="post-meta-item-text">阅读量 </em>
              <i class="leancloud-visitors-count">loading...</i>
            </span>
            

            
            
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

            
            
            
            
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'Uegmz6XvvmKhcQr2oE1XYFsp-MdYXbMMI',
		appKey: 'swFHTWbPQpdPHTquY8T14sAh',
		avatar: '',
		pageSize: 5,
		recordIp: true,
		placeholder: 'Leave me a message.',
		visitor: true,
	});
</script>

            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/zhiyu2011/zhiyu2011.github.io.git" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
            <li class="list-inline-item">
              <a href="https://www.jianshu.com/u/9371c5220dd6" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
            <li class="list-inline-item">
              <a href="https://weibo.com/zhiyu2011" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://2011369.xyz//atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>闫旭亮</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://2011369.xyz//media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://2011369.xyz//media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://2011369.xyz//media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://2011369.xyz//";
        addScript("https://2011369.xyz//media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://2011369.xyz//media/scripts/tocScript.js"></script>
</body>

</html>